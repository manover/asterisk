--- a/funcs/func_sysinfo.c
+++ b/funcs/func_sysinfo.c
@@ -29,6 +29,13 @@
 	<support_level>core</support_level>
  ***/
 
+
+#ifdef __ILP32__
+	#define L_FMT "ll"
+#else
+	#define L_FMT "l"
+#endif
+
 #include "asterisk.h"
 
 ASTERISK_REGISTER_FILE()
@@ -113,17 +120,17 @@ static int sysinfo_helper(struct ast_cha
 	}
 #if defined(HAVE_SYSINFO)
 	else if (!strcasecmp("uptime", data)) {             /* in hours */
-		snprintf(buf, len, "%ld", sys_info.uptime/3600);
+		snprintf(buf, len, "%"L_FMT"d", sys_info.uptime/3600);
 	} else if (!strcasecmp("totalram", data)) {         /* in KiB */
-		snprintf(buf, len, "%lu",(sys_info.totalram * sys_info.mem_unit)/1024);
+		snprintf(buf, len, "%"L_FMT"u",(sys_info.totalram * sys_info.mem_unit)/1024);
 	} else if (!strcasecmp("freeram", data)) {          /* in KiB */
-		snprintf(buf, len, "%lu",(sys_info.freeram * sys_info.mem_unit)/1024);
+		snprintf(buf, len, "%"L_FMT"u",(sys_info.freeram * sys_info.mem_unit)/1024);
 	} else if (!strcasecmp("bufferram", data)) {        /* in KiB */
-		snprintf(buf, len, "%lu",(sys_info.bufferram * sys_info.mem_unit)/1024);
+		snprintf(buf, len, "%"L_FMT"u",(sys_info.bufferram * sys_info.mem_unit)/1024);
 	} else if (!strcasecmp("totalswap", data)) {        /* in KiB */
-		snprintf(buf, len, "%lu",(sys_info.totalswap * sys_info.mem_unit)/1024);
+		snprintf(buf, len, "%"L_FMT"u",(sys_info.totalswap * sys_info.mem_unit)/1024);
 	} else if (!strcasecmp("freeswap", data)) {         /* in KiB */
-		snprintf(buf, len, "%lu",(sys_info.freeswap * sys_info.mem_unit)/1024);
+		snprintf(buf, len, "%"L_FMT"u",(sys_info.freeswap * sys_info.mem_unit)/1024);
 	} else if (!strcasecmp("numprocs", data)) {
 		snprintf(buf, len, "%d", sys_info.procs);
 	}
--- a/res/res_calendar_icalendar.c
+++ b/res/res_calendar_icalendar.c
@@ -246,7 +246,11 @@ static void icalendar_add_event(icalcomp
 			ast_string_field_set(event, uid, event->summary);
 		} else {
 			char tmp[100];
+#ifdef __ILP32__
+			snprintf(tmp, sizeof(tmp), "%lld", event->start);
+#else
 			snprintf(tmp, sizeof(tmp), "%ld", event->start);
+#endif
 			ast_string_field_set(event, uid, tmp);
 		}
 	}
--- a/res/res_http_media_cache.c
+++ b/res/res_http_media_cache.c
@@ -151,7 +151,11 @@ static void bucket_file_set_expiration(s
 	}
 
 	/* Use 'now' if we didn't get an expiration time */
+#ifdef __ILP32__
+	snprintf(time_buf, sizeof(time_buf), "%30llu", actual_expires.tv_sec);
+#else
 	snprintf(time_buf, sizeof(time_buf), "%30lu", actual_expires.tv_sec);
+#endif
 
 	ast_bucket_file_metadata_set(bucket_file, "__actual_expires", time_buf);
 }
@@ -192,7 +196,11 @@ static int bucket_file_expired(struct as
 		return 1;
 	}
 
+#ifdef __ILP32__
+	if (sscanf(metadata->value, "%llu", &expires.tv_sec) != 1) {
+#else
 	if (sscanf(metadata->value, "%lu", &expires.tv_sec) != 1) {
+#endif
 		return 1;
 	}
 
--- a/res/res_odbc.c
+++ b/res/res_odbc.c
@@ -933,7 +933,11 @@ static odbc_status odbc_obj_connect(stru
 	/* Dont connect while server is marked as unreachable via negative_connection_cache */
 	negative_cache_expiration = obj->parent->last_negative_connect.tv_sec + obj->parent->negative_connection_cache.tv_sec;
 	if (time(NULL) < negative_cache_expiration) {
+#ifdef __ILP32__
+		ast_log(LOG_WARNING, "Not connecting to %s. Negative connection cache for %lld seconds\n", obj->parent->name, negative_cache_expiration - time(NULL));
+#else
 		ast_log(LOG_WARNING, "Not connecting to %s. Negative connection cache for %ld seconds\n", obj->parent->name, negative_cache_expiration - time(NULL));
+#endif
 		return ODBC_FAIL;
 	}
 
--- a/res/res_pjsip_history.c
+++ b/res/res_pjsip_history.c
@@ -47,6 +47,12 @@ ASTERISK_REGISTER_FILE()
 
 #define HISTORY_INITIAL_SIZE 256
 
+#ifdef __ILP32__
+	#define T_FMT "lld"
+#else
+	#define T_FMT "ld"
+#endif
+
 /*! \brief Pool factory used by pjlib to allocate memory. */
 static pj_caching_pool cachingpool;
 
@@ -200,7 +206,7 @@ static int evaluate_equal(struct operato
 	{
 		struct timeval right = { 0, };
 
-		if (sscanf(op_right->field, "%ld", &right.tv_sec) != 1) {
+		if (sscanf(op_right->field, "%"T_FMT, &right.tv_sec) != 1) {
 			ast_log(LOG_WARNING, "Unable to extract field '%s': not a timestamp\n", op_right->field);
 			return -1;
 		}
@@ -271,7 +277,7 @@ static int evaluate_less_than(struct ope
 	{
 		struct timeval right = { 0, };
 
-		if (sscanf(op_right->field, "%ld", &right.tv_sec) != 1) {
+		if (sscanf(op_right->field, "%"T_FMT, &right.tv_sec) != 1) {
 			ast_log(LOG_WARNING, "Unable to extract field '%s': not a timestamp\n", op_right->field);
 			return -1;
 		}
@@ -320,7 +326,7 @@ static int evaluate_greater_than(struct
 	{
 		struct timeval right = { 0, };
 
-		if (sscanf(op_right->field, "%ld", &right.tv_sec) != 1) {
+		if (sscanf(op_right->field, "%"T_FMT, &right.tv_sec) != 1) {
 			ast_log(LOG_WARNING, "Unable to extract field '%s': not a timestamp\n", op_right->field);
 			return -1;
 		}
@@ -1153,7 +1159,7 @@ static void display_single_entry(struct
 		pj_sockaddr_print(&entry->src, addr, sizeof(addr), 3);
 	}
 
-	ast_cli(a->fd, "<--- History Entry %d %s %s at %-10.10ld --->\n",
+	ast_cli(a->fd, "<--- History Entry %d %s %s at %-10.10"T_FMT" --->\n",
 		entry->number,
 		entry->transmitted ? "Sent to" : "Received from",
 		addr,
--- a/res/res_pjsip_pubsub.c
+++ b/res/res_pjsip_pubsub.c
@@ -4405,7 +4405,11 @@ static int persistence_expires_str2struc
 static int persistence_expires_struct2str(const void *obj, const intptr_t *args, char **buf)
 {
 	const struct subscription_persistence *persistence = obj;
+#ifdef __ILP32__
+	return (ast_asprintf(buf, "%lld", persistence->expires.tv_sec) < 0) ? -1 : 0;
+#else
 	return (ast_asprintf(buf, "%ld", persistence->expires.tv_sec) < 0) ? -1 : 0;
+#endif
 }
 
 #define RESOURCE_LIST_INIT_SIZE 4
